{"version":3,"names":[],"mappings":"","sources":["css3-animate-it.js"],"sourcesContent":["/*\r\n * CSS3 Animate it\r\n * Copyright (c) 2014 Jack McCourt\r\n * https://github.com/kriegar/css3-animate-it\r\n * Version: 0.1.0\r\n * \r\n * I utilise the jQuery.appear plugin within this javascript file so here is a link to that too\r\n * https://github.com/morr/jquery.appear\r\n *\r\n * I also utilise the jQuery.doTimeout plugin for the data-sequence functionality so here is a link back to them.\r\n * http://benalman.com/projects/jquery-dotimeout-plugin/\r\n */\r\n(function ($) {\r\n    var selectors = [];\r\n\r\n    var check_binded = false;\r\n    var check_lock = false;\r\n    var defaults = {\r\n        interval: 250,\r\n        force_process: false\r\n    }\r\n    var $window = $(window);\r\n\r\n    var $prior_appeared;\r\n\r\n    function process() {\r\n        check_lock = false;\r\n        for (var index = 0; index < selectors.length; index++) {\r\n            var $appeared = $(selectors[index]).filter(function () {\r\n                return $(this).is(':appeared');\r\n            });\r\n\r\n            $appeared.trigger('appear', [$appeared]);\r\n\r\n            if ($prior_appeared) {\r\n\r\n                var $disappeared = $prior_appeared.not($appeared);\r\n                $disappeared.trigger('disappear', [$disappeared]);\r\n            }\r\n            $prior_appeared = $appeared;\r\n        }\r\n    }\r\n\r\n    // \"appeared\" custom filter\r\n    $.expr[':']['appeared'] = function (element) {\r\n        var $element = $(element);\r\n        if (!$element.is(':visible')) {\r\n            return false;\r\n        }\r\n\r\n        var window_left = $window.scrollLeft();\r\n        var window_top = $window.scrollTop();\r\n        var offset = $element.offset();\r\n        var left = offset.left;\r\n        var top = offset.top;\r\n\r\n        if (top + $element.height() >= window_top &&\r\n            top - ($element.data('appear-top-offset') || 0) <= window_top + $window.height() &&\r\n            left + $element.width() >= window_left &&\r\n            left - ($element.data('appear-left-offset') || 0) <= window_left + $window.width()) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    $.fn.extend({\r\n        // watching for element's appearance in browser viewport\r\n        appear: function (options) {\r\n            var opts = $.extend({}, defaults, options || {});\r\n            var selector = this.selector || this;\r\n            if (!check_binded) {\r\n                var on_check = function () {\r\n                    if (check_lock) {\r\n                        return;\r\n                    }\r\n                    check_lock = true;\r\n\r\n                    setTimeout(process, opts.interval);\r\n                };\r\n\r\n                $(window).scroll(on_check).resize(on_check);\r\n                check_binded = true;\r\n            }\r\n\r\n            if (opts.force_process) {\r\n                setTimeout(process, opts.interval);\r\n            }\r\n            selectors.push(selector);\r\n            return $(selector);\r\n        }\r\n    });\r\n\r\n    $.extend({\r\n        // force elements's appearance check\r\n        force_appear: function () {\r\n            if (check_binded) {\r\n                process();\r\n                return true;\r\n            }\r\n            ;\r\n            return false;\r\n        }\r\n    });\r\n})(jQuery);\r\n\r\n\r\n/*!\r\n * jQuery doTimeout: Like setTimeout, but better! - v1.0 - 3/3/2010\r\n * http://benalman.com/projects/jquery-dotimeout-plugin/\r\n * \r\n * Copyright (c) 2010 \"Cowboy\" Ben Alman\r\n * Dual licensed under the MIT and GPL licenses.\r\n * http://benalman.com/about/license/\r\n */\r\n\r\n// Script: jQuery doTimeout: Like setTimeout, but better!\r\n//\r\n// *Version: 1.0, Last updated: 3/3/2010*\r\n// \r\n// Project Home - http://benalman.com/projects/jquery-dotimeout-plugin/\r\n// GitHub       - http://github.com/cowboy/jquery-dotimeout/\r\n// Source       - http://github.com/cowboy/jquery-dotimeout/raw/master/jquery.ba-dotimeout.js\r\n// (Minified)   - http://github.com/cowboy/jquery-dotimeout/raw/master/jquery.ba-dotimeout.min.js (1.0kb)\r\n// \r\n// About: License\r\n// \r\n// Copyright (c) 2010 \"Cowboy\" Ben Alman,\r\n// Dual licensed under the MIT and GPL licenses.\r\n// http://benalman.com/about/license/\r\n// \r\n// About: Examples\r\n// \r\n// These working examples, complete with fully commented code, illustrate a few\r\n// ways in which this plugin can be used.\r\n// \r\n// Debouncing      - http://benalman.com/code/projects/jquery-dotimeout/examples/debouncing/\r\n// Delays, Polling - http://benalman.com/code/projects/jquery-dotimeout/examples/delay-poll/\r\n// Hover Intent    - http://benalman.com/code/projects/jquery-dotimeout/examples/hoverintent/\r\n// \r\n// About: Support and Testing\r\n// \r\n// Information about what version or versions of jQuery this plugin has been\r\n// tested with, what browsers it has been tested in, and where the unit tests\r\n// reside (so you can test it yourself).\r\n// \r\n// jQuery Versions - 1.3.2, 1.4.2\r\n// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome 4-5, Opera 9.6-10.1.\r\n// Unit Tests      - http://benalman.com/code/projects/jquery-dotimeout/unit/\r\n// \r\n// About: Release History\r\n// \r\n// 1.0 - (3/3/2010) Callback can now be a string, in which case it will call\r\n//       the appropriate $.method or $.fn.method, depending on where .doTimeout\r\n//       was called. Callback must now return `true` (not just a truthy value)\r\n//       to poll.\r\n// 0.4 - (7/15/2009) Made the \"id\" argument optional, some other minor tweaks\r\n// 0.3 - (6/25/2009) Initial release\r\n\r\n(function ($) {\r\n    '$:nomunge'; // Used by YUI compressor.\r\n\r\n    var cache = {},\r\n\r\n    // Reused internal string.\r\n        doTimeout = 'doTimeout',\r\n\r\n    // A convenient shortcut.\r\n        aps = Array.prototype.slice;\r\n\r\n    // Method: jQuery.doTimeout\r\n    // \r\n    // Initialize, cancel, or force execution of a callback after a delay.\r\n    // \r\n    // If delay and callback are specified, a doTimeout is initialized. The\r\n    // callback will execute, asynchronously, after the delay. If an id is\r\n    // specified, this doTimeout will override and cancel any existing doTimeout\r\n    // with the same id. Any additional arguments will be passed into callback\r\n    // when it is executed.\r\n    // \r\n    // If the callback returns true, the doTimeout loop will execute again, after\r\n    // the delay, creating a polling loop until the callback returns a non-true\r\n    // value.\r\n    // \r\n    // Note that if an id is not passed as the first argument, this doTimeout will\r\n    // NOT be able to be manually canceled or forced. (for debouncing, be sure to\r\n    // specify an id).\r\n    // \r\n    // If id is specified, but delay and callback are not, the doTimeout will be\r\n    // canceled without executing the callback. If force_mode is specified, the\r\n    // callback will be executed, synchronously, but will only be allowed to\r\n    // continue a polling loop if force_mode is true (provided the callback\r\n    // returns true, of course). If force_mode is false, no polling loop will\r\n    // continue, even if the callback returns true.\r\n    // \r\n    // Usage:\r\n    // \r\n    // > jQuery.doTimeout( [ id, ] delay, callback [, arg ... ] );\r\n    // > jQuery.doTimeout( id [, force_mode ] );\r\n    // \r\n    // Arguments:\r\n    // \r\n    //  id - (String) An optional unique identifier for this doTimeout. If id is\r\n    //    not specified, the doTimeout will NOT be able to be manually canceled or\r\n    //    forced.\r\n    //  delay - (Number) A zero-or-greater delay in milliseconds after which\r\n    //    callback will be executed. \r\n    //  callback - (Function) A function to be executed after delay milliseconds.\r\n    //  callback - (String) A jQuery method to be executed after delay\r\n    //    milliseconds. This method will only poll if it explicitly returns\r\n    //    true.\r\n    //  force_mode - (Boolean) If true, execute that id's doTimeout callback\r\n    //    immediately and synchronously, continuing any callback return-true\r\n    //    polling loop. If false, execute the callback immediately and\r\n    //    synchronously but do NOT continue a callback return-true polling loop.\r\n    //    If omitted, cancel that id's doTimeout.\r\n    // \r\n    // Returns:\r\n    // \r\n    //  If force_mode is true, false or undefined and there is a\r\n    //  yet-to-be-executed callback to cancel, true is returned, but if no\r\n    //  callback remains to be executed, undefined is returned.\r\n\r\n    $[doTimeout] = function () {\r\n        return p_doTimeout.apply(window, [0].concat(aps.call(arguments)));\r\n    };\r\n\r\n    // Method: jQuery.fn.doTimeout\r\n    // \r\n    // Initialize, cancel, or force execution of a callback after a delay.\r\n    // Operates like <jQuery.doTimeout>, but the passed callback executes in the\r\n    // context of the jQuery collection of elements, and the id is stored as data\r\n    // on the first element in that collection.\r\n    // \r\n    // If delay and callback are specified, a doTimeout is initialized. The\r\n    // callback will execute, asynchronously, after the delay. If an id is\r\n    // specified, this doTimeout will override and cancel any existing doTimeout\r\n    // with the same id. Any additional arguments will be passed into callback\r\n    // when it is executed.\r\n    // \r\n    // If the callback returns true, the doTimeout loop will execute again, after\r\n    // the delay, creating a polling loop until the callback returns a non-true\r\n    // value.\r\n    // \r\n    // Note that if an id is not passed as the first argument, this doTimeout will\r\n    // NOT be able to be manually canceled or forced (for debouncing, be sure to\r\n    // specify an id).\r\n    // \r\n    // If id is specified, but delay and callback are not, the doTimeout will be\r\n    // canceled without executing the callback. If force_mode is specified, the\r\n    // callback will be executed, synchronously, but will only be allowed to\r\n    // continue a polling loop if force_mode is true (provided the callback\r\n    // returns true, of course). If force_mode is false, no polling loop will\r\n    // continue, even if the callback returns true.\r\n    // \r\n    // Usage:\r\n    // \r\n    // > jQuery('selector').doTimeout( [ id, ] delay, callback [, arg ... ] );\r\n    // > jQuery('selector').doTimeout( id [, force_mode ] );\r\n    // \r\n    // Arguments:\r\n    // \r\n    //  id - (String) An optional unique identifier for this doTimeout, stored as\r\n    //    jQuery data on the element. If id is not specified, the doTimeout will\r\n    //    NOT be able to be manually canceled or forced.\r\n    //  delay - (Number) A zero-or-greater delay in milliseconds after which\r\n    //    callback will be executed. \r\n    //  callback - (Function) A function to be executed after delay milliseconds.\r\n    //  callback - (String) A jQuery.fn method to be executed after delay\r\n    //    milliseconds. This method will only poll if it explicitly returns\r\n    //    true (most jQuery.fn methods return a jQuery object, and not `true`,\r\n    //    which allows them to be chained and prevents polling).\r\n    //  force_mode - (Boolean) If true, execute that id's doTimeout callback\r\n    //    immediately and synchronously, continuing any callback return-true\r\n    //    polling loop. If false, execute the callback immediately and\r\n    //    synchronously but do NOT continue a callback return-true polling loop.\r\n    //    If omitted, cancel that id's doTimeout.\r\n    // \r\n    // Returns:\r\n    // \r\n    //  When creating a <jQuery.fn.doTimeout>, the initial jQuery collection of\r\n    //  elements is returned. Otherwise, if force_mode is true, false or undefined\r\n    //  and there is a yet-to-be-executed callback to cancel, true is returned,\r\n    //  but if no callback remains to be executed, undefined is returned.\r\n\r\n    $.fn[doTimeout] = function () {\r\n        var args = aps.call(arguments),\r\n            result = p_doTimeout.apply(this, [doTimeout + args[0]].concat(args));\r\n\r\n        return typeof args[0] === 'number' || typeof args[1] === 'number'\r\n            ? this\r\n            : result;\r\n    };\r\n\r\n    function p_doTimeout(jquery_data_key) {\r\n        var that = this,\r\n            elem,\r\n            data = {},\r\n\r\n        // Allows the plugin to call a string callback method.\r\n            method_base = jquery_data_key ? $.fn : $,\r\n\r\n        // Any additional arguments will be passed to the callback.\r\n            args = arguments,\r\n            slice_args = 4,\r\n\r\n            id = args[1],\r\n            delay = args[2],\r\n            callback = args[3];\r\n\r\n        if (typeof id !== 'string') {\r\n            slice_args--;\r\n\r\n            id = jquery_data_key = 0;\r\n            delay = args[1];\r\n            callback = args[2];\r\n        }\r\n\r\n        // If id is passed, store a data reference either as .data on the first\r\n        // element in a jQuery collection, or in the internal cache.\r\n        if (jquery_data_key) { // Note: key is 'doTimeout' + id\r\n\r\n            // Get id-object from the first element's data, otherwise initialize it to {}.\r\n            elem = that.eq(0);\r\n            elem.data(jquery_data_key, data = elem.data(jquery_data_key) || {});\r\n\r\n        } else if (id) {\r\n            // Get id-object from the cache, otherwise initialize it to {}.\r\n            data = cache[id] || ( cache[id] = {} );\r\n        }\r\n\r\n        // Clear any existing timeout for this id.\r\n        data.id && clearTimeout(data.id);\r\n        delete data.id;\r\n\r\n        // Clean up when necessary.\r\n        function cleanup() {\r\n            if (jquery_data_key) {\r\n                elem.removeData(jquery_data_key);\r\n            } else if (id) {\r\n                delete cache[id];\r\n            }\r\n        };\r\n\r\n        // Yes, there actually is a setTimeout call in here!\r\n        function actually_setTimeout() {\r\n            data.id = setTimeout(function () {\r\n                data.fn();\r\n            }, delay);\r\n        };\r\n\r\n        if (callback) {\r\n            // A callback (and delay) were specified. Store the callback reference for\r\n            // possible later use, and then setTimeout.\r\n            data.fn = function (no_polling_loop) {\r\n\r\n                // If the callback value is a string, it is assumed to be the name of a\r\n                // method on $ or $.fn depending on where doTimeout was executed.\r\n                if (typeof callback === 'string') {\r\n                    callback = method_base[callback];\r\n                }\r\n\r\n                callback.apply(that, aps.call(args, slice_args)) === true && !no_polling_loop\r\n\r\n                    // Since the callback returned true, and we're not specifically\r\n                    // canceling a polling loop, do it again!\r\n                    ? actually_setTimeout()\r\n\r\n                    // Otherwise, clean up and quit.\r\n                    : cleanup();\r\n            };\r\n\r\n            // Set that timeout!\r\n            actually_setTimeout();\r\n\r\n        } else if (data.fn) {\r\n            // No callback passed. If force_mode (delay) is true, execute the data.fn\r\n            // callback immediately, continuing any callback return-true polling loop.\r\n            // If force_mode is false, execute the data.fn callback immediately but do\r\n            // NOT continue a callback return-true polling loop. If force_mode is\r\n            // undefined, simply clean up. Since data.fn was still defined, whatever\r\n            // was supposed to happen hadn't yet, so return true.\r\n            delay === undefined ? cleanup() : data.fn(delay === false);\r\n            return true;\r\n\r\n        } else {\r\n            // Since no callback was passed, and data.fn isn't defined, it looks like\r\n            // whatever was supposed to happen already did. Clean up and quit!\r\n            cleanup();\r\n        }\r\n\r\n    };\r\n\r\n})(jQuery);\r\n\r\n\r\n//CSS3 Animate-it\r\n$('.animatedParent').appear();\r\n$('.animatedClick').click(function () {\r\n    var target = $(this).attr('data-target');\r\n\r\n\r\n    if ($(this).attr('data-sequence') != undefined) {\r\n        var firstId = $(\".\" + target + \":first\").attr('data-id');\r\n        var lastId = $(\".\" + target + \":last\").attr('data-id');\r\n        var number = firstId;\r\n\r\n        //Add or remove the class\r\n        if ($(\".\" + target + \"[data-id=\" + number + \"]\").hasClass('go')) {\r\n            $(\".\" + target + \"[data-id=\" + number + \"]\").addClass('goAway');\r\n            $(\".\" + target + \"[data-id=\" + number + \"]\").removeClass('go');\r\n        } else {\r\n            $(\".\" + target + \"[data-id=\" + number + \"]\").addClass('go');\r\n            $(\".\" + target + \"[data-id=\" + number + \"]\").removeClass('goAway');\r\n        }\r\n        number++;\r\n        delay = Number($(this).attr('data-sequence'));\r\n        $.doTimeout(delay, function () {\r\n            console.log(lastId);\r\n\r\n            //Add or remove the class\r\n            if ($(\".\" + target + \"[data-id=\" + number + \"]\").hasClass('go')) {\r\n                $(\".\" + target + \"[data-id=\" + number + \"]\").addClass('goAway');\r\n                $(\".\" + target + \"[data-id=\" + number + \"]\").removeClass('go');\r\n            } else {\r\n                $(\".\" + target + \"[data-id=\" + number + \"]\").addClass('go');\r\n                $(\".\" + target + \"[data-id=\" + number + \"]\").removeClass('goAway');\r\n            }\r\n\r\n            //increment\r\n            ++number;\r\n\r\n            //continute looping till reached last ID\r\n            if (number <= lastId) {\r\n                return true;\r\n            }\r\n        });\r\n    } else {\r\n        if ($('.' + target).hasClass('go')) {\r\n            $('.' + target).addClass('goAway');\r\n            $('.' + target).removeClass('go');\r\n        } else {\r\n            $('.' + target).addClass('go');\r\n            $('.' + target).removeClass('goAway');\r\n        }\r\n    }\r\n});\r\n\r\n$(document.body).on('appear', '.animatedParent', function (e, $affected) {\r\n    var ele = $(this).find('.animated');\r\n    var parent = $(this);\r\n\r\n\r\n    if (parent.attr('data-sequence') != undefined) {\r\n\r\n        var firstId = $(this).find('.animated:first').attr('data-id');\r\n        var number = firstId;\r\n        var lastId = $(this).find('.animated:last').attr('data-id');\r\n\r\n        $(parent).find(\".animated[data-id=\" + number + \"]\").addClass('go');\r\n        number++;\r\n        delay = Number(parent.attr('data-sequence'));\r\n\r\n        $.doTimeout(delay, function () {\r\n            $(parent).find(\".animated[data-id=\" + number + \"]\").addClass('go');\r\n            ++number;\r\n            if (number <= lastId) {\r\n                return true;\r\n            }\r\n        });\r\n    } else {\r\n        ele.addClass('go');\r\n    }\r\n\r\n});\r\n\r\n$(document.body).on('disappear', '.animatedParent', function (e, $affected) {\r\n    if (!$(this).hasClass('animateOnce')) {\r\n        $(this).find('.animated').removeClass('go');\r\n    }\r\n});\r\n\r\n$(window).on('load', function () {\r\n    $.force_appear();\r\n});\r\n"],"file":"css3-animate-it.js"}