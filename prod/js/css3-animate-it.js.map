{"version":3,"names":[],"mappings":"","sources":["css3-animate-it.js"],"sourcesContent":["/*\n * CSS3 Animate it\n * Copyright (c) 2014 Jack McCourt\n * https://github.com/kriegar/css3-animate-it\n * Version: 0.1.0\n * \n * I utilise the jQuery.appear plugin within this javascript file so here is a link to that too\n * https://github.com/morr/jquery.appear\n *\n * I also utilise the jQuery.doTimeout plugin for the data-sequence functionality so here is a link back to them.\n * http://benalman.com/projects/jquery-dotimeout-plugin/\n */\n(function ($) {\n    var selectors = [];\n\n    var check_binded = false;\n    var check_lock = false;\n    var defaults = {\n        interval: 250,\n        force_process: false\n    }\n    var $window = $(window);\n\n    var $prior_appeared;\n\n    function process() {\n        check_lock = false;\n        for (var index = 0; index < selectors.length; index++) {\n            var $appeared = $(selectors[index]).filter(function () {\n                return $(this).is(':appeared');\n            });\n\n            $appeared.trigger('appear', [$appeared]);\n\n            if ($prior_appeared) {\n\n                var $disappeared = $prior_appeared.not($appeared);\n                $disappeared.trigger('disappear', [$disappeared]);\n            }\n            $prior_appeared = $appeared;\n        }\n    }\n\n    // \"appeared\" custom filter\n    $.expr[':']['appeared'] = function (element) {\n        var $element = $(element);\n        if (!$element.is(':visible')) {\n            return false;\n        }\n\n        var window_left = $window.scrollLeft();\n        var window_top = $window.scrollTop();\n        var offset = $element.offset();\n        var left = offset.left;\n        var top = offset.top;\n\n        if (top + $element.height() >= window_top &&\n            top - ($element.data('appear-top-offset') || 0) <= window_top + $window.height() &&\n            left + $element.width() >= window_left &&\n            left - ($element.data('appear-left-offset') || 0) <= window_left + $window.width()) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    $.fn.extend({\n        // watching for element's appearance in browser viewport\n        appear: function (options) {\n            var opts = $.extend({}, defaults, options || {});\n            var selector = this.selector || this;\n            if (!check_binded) {\n                var on_check = function () {\n                    if (check_lock) {\n                        return;\n                    }\n                    check_lock = true;\n\n                    setTimeout(process, opts.interval);\n                };\n\n                $(window).scroll(on_check).resize(on_check);\n                check_binded = true;\n            }\n\n            if (opts.force_process) {\n                setTimeout(process, opts.interval);\n            }\n            selectors.push(selector);\n            return $(selector);\n        }\n    });\n\n    $.extend({\n        // force elements's appearance check\n        force_appear: function () {\n            if (check_binded) {\n                process();\n                return true;\n            }\n            ;\n            return false;\n        }\n    });\n})(jQuery);\n\n\n/*!\n * jQuery doTimeout: Like setTimeout, but better! - v1.0 - 3/3/2010\n * http://benalman.com/projects/jquery-dotimeout-plugin/\n * \n * Copyright (c) 2010 \"Cowboy\" Ben Alman\n * Dual licensed under the MIT and GPL licenses.\n * http://benalman.com/about/license/\n */\n\n// Script: jQuery doTimeout: Like setTimeout, but better!\n//\n// *Version: 1.0, Last updated: 3/3/2010*\n// \n// Project Home - http://benalman.com/projects/jquery-dotimeout-plugin/\n// GitHub       - http://github.com/cowboy/jquery-dotimeout/\n// Source       - http://github.com/cowboy/jquery-dotimeout/raw/master/jquery.ba-dotimeout.js\n// (Minified)   - http://github.com/cowboy/jquery-dotimeout/raw/master/jquery.ba-dotimeout.min.js (1.0kb)\n// \n// About: License\n// \n// Copyright (c) 2010 \"Cowboy\" Ben Alman,\n// Dual licensed under the MIT and GPL licenses.\n// http://benalman.com/about/license/\n// \n// About: Examples\n// \n// These working examples, complete with fully commented code, illustrate a few\n// ways in which this plugin can be used.\n// \n// Debouncing      - http://benalman.com/code/projects/jquery-dotimeout/examples/debouncing/\n// Delays, Polling - http://benalman.com/code/projects/jquery-dotimeout/examples/delay-poll/\n// Hover Intent    - http://benalman.com/code/projects/jquery-dotimeout/examples/hoverintent/\n// \n// About: Support and Testing\n// \n// Information about what version or versions of jQuery this plugin has been\n// tested with, what browsers it has been tested in, and where the unit tests\n// reside (so you can test it yourself).\n// \n// jQuery Versions - 1.3.2, 1.4.2\n// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome 4-5, Opera 9.6-10.1.\n// Unit Tests      - http://benalman.com/code/projects/jquery-dotimeout/unit/\n// \n// About: Release History\n// \n// 1.0 - (3/3/2010) Callback can now be a string, in which case it will call\n//       the appropriate $.method or $.fn.method, depending on where .doTimeout\n//       was called. Callback must now return `true` (not just a truthy value)\n//       to poll.\n// 0.4 - (7/15/2009) Made the \"id\" argument optional, some other minor tweaks\n// 0.3 - (6/25/2009) Initial release\n\n(function ($) {\n    '$:nomunge'; // Used by YUI compressor.\n\n    var cache = {},\n\n    // Reused internal string.\n        doTimeout = 'doTimeout',\n\n    // A convenient shortcut.\n        aps = Array.prototype.slice;\n\n    // Method: jQuery.doTimeout\n    // \n    // Initialize, cancel, or force execution of a callback after a delay.\n    // \n    // If delay and callback are specified, a doTimeout is initialized. The\n    // callback will execute, asynchronously, after the delay. If an id is\n    // specified, this doTimeout will override and cancel any existing doTimeout\n    // with the same id. Any additional arguments will be passed into callback\n    // when it is executed.\n    // \n    // If the callback returns true, the doTimeout loop will execute again, after\n    // the delay, creating a polling loop until the callback returns a non-true\n    // value.\n    // \n    // Note that if an id is not passed as the first argument, this doTimeout will\n    // NOT be able to be manually canceled or forced. (for debouncing, be sure to\n    // specify an id).\n    // \n    // If id is specified, but delay and callback are not, the doTimeout will be\n    // canceled without executing the callback. If force_mode is specified, the\n    // callback will be executed, synchronously, but will only be allowed to\n    // continue a polling loop if force_mode is true (provided the callback\n    // returns true, of course). If force_mode is false, no polling loop will\n    // continue, even if the callback returns true.\n    // \n    // Usage:\n    // \n    // > jQuery.doTimeout( [ id, ] delay, callback [, arg ... ] );\n    // > jQuery.doTimeout( id [, force_mode ] );\n    // \n    // Arguments:\n    // \n    //  id - (String) An optional unique identifier for this doTimeout. If id is\n    //    not specified, the doTimeout will NOT be able to be manually canceled or\n    //    forced.\n    //  delay - (Number) A zero-or-greater delay in milliseconds after which\n    //    callback will be executed. \n    //  callback - (Function) A function to be executed after delay milliseconds.\n    //  callback - (String) A jQuery method to be executed after delay\n    //    milliseconds. This method will only poll if it explicitly returns\n    //    true.\n    //  force_mode - (Boolean) If true, execute that id's doTimeout callback\n    //    immediately and synchronously, continuing any callback return-true\n    //    polling loop. If false, execute the callback immediately and\n    //    synchronously but do NOT continue a callback return-true polling loop.\n    //    If omitted, cancel that id's doTimeout.\n    // \n    // Returns:\n    // \n    //  If force_mode is true, false or undefined and there is a\n    //  yet-to-be-executed callback to cancel, true is returned, but if no\n    //  callback remains to be executed, undefined is returned.\n\n    $[doTimeout] = function () {\n        return p_doTimeout.apply(window, [0].concat(aps.call(arguments)));\n    };\n\n    // Method: jQuery.fn.doTimeout\n    // \n    // Initialize, cancel, or force execution of a callback after a delay.\n    // Operates like <jQuery.doTimeout>, but the passed callback executes in the\n    // context of the jQuery collection of elements, and the id is stored as data\n    // on the first element in that collection.\n    // \n    // If delay and callback are specified, a doTimeout is initialized. The\n    // callback will execute, asynchronously, after the delay. If an id is\n    // specified, this doTimeout will override and cancel any existing doTimeout\n    // with the same id. Any additional arguments will be passed into callback\n    // when it is executed.\n    // \n    // If the callback returns true, the doTimeout loop will execute again, after\n    // the delay, creating a polling loop until the callback returns a non-true\n    // value.\n    // \n    // Note that if an id is not passed as the first argument, this doTimeout will\n    // NOT be able to be manually canceled or forced (for debouncing, be sure to\n    // specify an id).\n    // \n    // If id is specified, but delay and callback are not, the doTimeout will be\n    // canceled without executing the callback. If force_mode is specified, the\n    // callback will be executed, synchronously, but will only be allowed to\n    // continue a polling loop if force_mode is true (provided the callback\n    // returns true, of course). If force_mode is false, no polling loop will\n    // continue, even if the callback returns true.\n    // \n    // Usage:\n    // \n    // > jQuery('selector').doTimeout( [ id, ] delay, callback [, arg ... ] );\n    // > jQuery('selector').doTimeout( id [, force_mode ] );\n    // \n    // Arguments:\n    // \n    //  id - (String) An optional unique identifier for this doTimeout, stored as\n    //    jQuery data on the element. If id is not specified, the doTimeout will\n    //    NOT be able to be manually canceled or forced.\n    //  delay - (Number) A zero-or-greater delay in milliseconds after which\n    //    callback will be executed. \n    //  callback - (Function) A function to be executed after delay milliseconds.\n    //  callback - (String) A jQuery.fn method to be executed after delay\n    //    milliseconds. This method will only poll if it explicitly returns\n    //    true (most jQuery.fn methods return a jQuery object, and not `true`,\n    //    which allows them to be chained and prevents polling).\n    //  force_mode - (Boolean) If true, execute that id's doTimeout callback\n    //    immediately and synchronously, continuing any callback return-true\n    //    polling loop. If false, execute the callback immediately and\n    //    synchronously but do NOT continue a callback return-true polling loop.\n    //    If omitted, cancel that id's doTimeout.\n    // \n    // Returns:\n    // \n    //  When creating a <jQuery.fn.doTimeout>, the initial jQuery collection of\n    //  elements is returned. Otherwise, if force_mode is true, false or undefined\n    //  and there is a yet-to-be-executed callback to cancel, true is returned,\n    //  but if no callback remains to be executed, undefined is returned.\n\n    $.fn[doTimeout] = function () {\n        var args = aps.call(arguments),\n            result = p_doTimeout.apply(this, [doTimeout + args[0]].concat(args));\n\n        return typeof args[0] === 'number' || typeof args[1] === 'number'\n            ? this\n            : result;\n    };\n\n    function p_doTimeout(jquery_data_key) {\n        var that = this,\n            elem,\n            data = {},\n\n        // Allows the plugin to call a string callback method.\n            method_base = jquery_data_key ? $.fn : $,\n\n        // Any additional arguments will be passed to the callback.\n            args = arguments,\n            slice_args = 4,\n\n            id = args[1],\n            delay = args[2],\n            callback = args[3];\n\n        if (typeof id !== 'string') {\n            slice_args--;\n\n            id = jquery_data_key = 0;\n            delay = args[1];\n            callback = args[2];\n        }\n\n        // If id is passed, store a data reference either as .data on the first\n        // element in a jQuery collection, or in the internal cache.\n        if (jquery_data_key) { // Note: key is 'doTimeout' + id\n\n            // Get id-object from the first element's data, otherwise initialize it to {}.\n            elem = that.eq(0);\n            elem.data(jquery_data_key, data = elem.data(jquery_data_key) || {});\n\n        } else if (id) {\n            // Get id-object from the cache, otherwise initialize it to {}.\n            data = cache[id] || ( cache[id] = {} );\n        }\n\n        // Clear any existing timeout for this id.\n        data.id && clearTimeout(data.id);\n        delete data.id;\n\n        // Clean up when necessary.\n        function cleanup() {\n            if (jquery_data_key) {\n                elem.removeData(jquery_data_key);\n            } else if (id) {\n                delete cache[id];\n            }\n        };\n\n        // Yes, there actually is a setTimeout call in here!\n        function actually_setTimeout() {\n            data.id = setTimeout(function () {\n                data.fn();\n            }, delay);\n        };\n\n        if (callback) {\n            // A callback (and delay) were specified. Store the callback reference for\n            // possible later use, and then setTimeout.\n            data.fn = function (no_polling_loop) {\n\n                // If the callback value is a string, it is assumed to be the name of a\n                // method on $ or $.fn depending on where doTimeout was executed.\n                if (typeof callback === 'string') {\n                    callback = method_base[callback];\n                }\n\n                callback.apply(that, aps.call(args, slice_args)) === true && !no_polling_loop\n\n                    // Since the callback returned true, and we're not specifically\n                    // canceling a polling loop, do it again!\n                    ? actually_setTimeout()\n\n                    // Otherwise, clean up and quit.\n                    : cleanup();\n            };\n\n            // Set that timeout!\n            actually_setTimeout();\n\n        } else if (data.fn) {\n            // No callback passed. If force_mode (delay) is true, execute the data.fn\n            // callback immediately, continuing any callback return-true polling loop.\n            // If force_mode is false, execute the data.fn callback immediately but do\n            // NOT continue a callback return-true polling loop. If force_mode is\n            // undefined, simply clean up. Since data.fn was still defined, whatever\n            // was supposed to happen hadn't yet, so return true.\n            delay === undefined ? cleanup() : data.fn(delay === false);\n            return true;\n\n        } else {\n            // Since no callback was passed, and data.fn isn't defined, it looks like\n            // whatever was supposed to happen already did. Clean up and quit!\n            cleanup();\n        }\n\n    };\n\n})(jQuery);\n\n\n//CSS3 Animate-it\n$('.animatedParent').appear();\n$('.animatedClick').click(function () {\n    var target = $(this).attr('data-target');\n\n\n    if ($(this).attr('data-sequence') != undefined) {\n        var firstId = $(\".\" + target + \":first\").attr('data-id');\n        var lastId = $(\".\" + target + \":last\").attr('data-id');\n        var number = firstId;\n\n        //Add or remove the class\n        if ($(\".\" + target + \"[data-id=\" + number + \"]\").hasClass('go')) {\n            $(\".\" + target + \"[data-id=\" + number + \"]\").addClass('goAway');\n            $(\".\" + target + \"[data-id=\" + number + \"]\").removeClass('go');\n        } else {\n            $(\".\" + target + \"[data-id=\" + number + \"]\").addClass('go');\n            $(\".\" + target + \"[data-id=\" + number + \"]\").removeClass('goAway');\n        }\n        number++;\n        delay = Number($(this).attr('data-sequence'));\n        $.doTimeout(delay, function () {\n            console.log(lastId);\n\n            //Add or remove the class\n            if ($(\".\" + target + \"[data-id=\" + number + \"]\").hasClass('go')) {\n                $(\".\" + target + \"[data-id=\" + number + \"]\").addClass('goAway');\n                $(\".\" + target + \"[data-id=\" + number + \"]\").removeClass('go');\n            } else {\n                $(\".\" + target + \"[data-id=\" + number + \"]\").addClass('go');\n                $(\".\" + target + \"[data-id=\" + number + \"]\").removeClass('goAway');\n            }\n\n            //increment\n            ++number;\n\n            //continute looping till reached last ID\n            if (number <= lastId) {\n                return true;\n            }\n        });\n    } else {\n        if ($('.' + target).hasClass('go')) {\n            $('.' + target).addClass('goAway');\n            $('.' + target).removeClass('go');\n        } else {\n            $('.' + target).addClass('go');\n            $('.' + target).removeClass('goAway');\n        }\n    }\n});\n\n$(document.body).on('appear', '.animatedParent', function (e, $affected) {\n    var ele = $(this).find('.animated');\n    var parent = $(this);\n\n\n    if (parent.attr('data-sequence') != undefined) {\n\n        var firstId = $(this).find('.animated:first').attr('data-id');\n        var number = firstId;\n        var lastId = $(this).find('.animated:last').attr('data-id');\n\n        $(parent).find(\".animated[data-id=\" + number + \"]\").addClass('go');\n        number++;\n        delay = Number(parent.attr('data-sequence'));\n\n        $.doTimeout(delay, function () {\n            $(parent).find(\".animated[data-id=\" + number + \"]\").addClass('go');\n            ++number;\n            if (number <= lastId) {\n                return true;\n            }\n        });\n    } else {\n        ele.addClass('go');\n    }\n\n});\n\n$(document.body).on('disappear', '.animatedParent', function (e, $affected) {\n    if (!$(this).hasClass('animateOnce')) {\n        $(this).find('.animated').removeClass('go');\n    }\n});\n\n$(window).on('load', function () {\n    $.force_appear();\n});\n"],"file":"css3-animate-it.js"}