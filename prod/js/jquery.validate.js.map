{"version":3,"names":[],"mappings":"","sources":["jquery.validate.js"],"sourcesContent":["/*!\r\n * jQuery Validation Plugin v1.16.0\r\n *\r\n * http://jqueryvalidation.org/\r\n *\r\n * Copyright (c) 2016 JÃ¶rn Zaefferer\r\n * Released under the MIT license\r\n */\r\n(function (factory) {\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define([\"jquery\"], factory);\r\n    } else if (typeof module === \"object\" && module.exports) {\r\n        module.exports = factory(require(\"jquery\"));\r\n    } else {\r\n        factory(jQuery);\r\n    }\r\n}(function ($) {\r\n\r\n    $.extend($.fn, {\r\n\r\n        // http://jqueryvalidation.org/validate/\r\n        validate: function (options) {\r\n\r\n            // If nothing is selected, return nothing; can't chain anyway\r\n            if (!this.length) {\r\n                if (options && options.debug && window.console) {\r\n                    console.warn(\"Nothing selected, can't validate, returning nothing.\");\r\n                }\r\n                return;\r\n            }\r\n\r\n            // Check if a validator for this form was already created\r\n            var validator = $.data(this[0], \"validator\");\r\n            if (validator) {\r\n                return validator;\r\n            }\r\n\r\n            // Add novalidate tag if HTML5.\r\n            this.attr(\"novalidate\", \"novalidate\");\r\n\r\n            validator = new $.validator(options, this[0]);\r\n            $.data(this[0], \"validator\", validator);\r\n\r\n            if (validator.settings.onsubmit) {\r\n\r\n                this.on(\"click.validate\", \":submit\", function (event) {\r\n                    if (validator.settings.submitHandler) {\r\n                        validator.submitButton = event.target;\r\n                    }\r\n\r\n                    // Allow suppressing validation by adding a cancel class to the submit button\r\n                    if ($(this).hasClass(\"cancel\")) {\r\n                        validator.cancelSubmit = true;\r\n                    }\r\n\r\n                    // Allow suppressing validation by adding the html5 formnovalidate attribute to the submit button\r\n                    if ($(this).attr(\"formnovalidate\") !== undefined) {\r\n                        validator.cancelSubmit = true;\r\n                    }\r\n                });\r\n\r\n                // Validate the form on submit\r\n                this.on(\"submit.validate\", function (event) {\r\n                    if (validator.settings.debug) {\r\n\r\n                        // Prevent form submit to be able to see console output\r\n                        event.preventDefault();\r\n                    }\r\n                    function handle() {\r\n                        var hidden, result;\r\n                        if (validator.settings.submitHandler) {\r\n                            if (validator.submitButton) {\r\n\r\n                                // Insert a hidden input as a replacement for the missing submit button\r\n                                hidden = $(\"<input type='hidden'/>\")\r\n                                    .attr(\"name\", validator.submitButton.name)\r\n                                    .val($(validator.submitButton).val())\r\n                                    .appendTo(validator.currentForm);\r\n                            }\r\n                            result = validator.settings.submitHandler.call(validator, validator.currentForm, event);\r\n                            if (validator.submitButton) {\r\n\r\n                                // And clean up afterwards; thanks to no-block-scope, hidden can be referenced\r\n                                hidden.remove();\r\n                            }\r\n                            if (result !== undefined) {\r\n                                return result;\r\n                            }\r\n                            return false;\r\n                        }\r\n                        return true;\r\n                    }\r\n\r\n                    // Prevent submit for invalid forms or custom submit handlers\r\n                    if (validator.cancelSubmit) {\r\n                        validator.cancelSubmit = false;\r\n                        return handle();\r\n                    }\r\n                    if (validator.form()) {\r\n                        if (validator.pendingRequest) {\r\n                            validator.formSubmitted = true;\r\n                            return false;\r\n                        }\r\n                        return handle();\r\n                    } else {\r\n                        validator.focusInvalid();\r\n                        return false;\r\n                    }\r\n                });\r\n            }\r\n\r\n            return validator;\r\n        },\r\n\r\n        // http://jqueryvalidation.org/valid/\r\n        valid: function () {\r\n            var valid, validator, errorList;\r\n\r\n            if ($(this[0]).is(\"form\")) {\r\n                valid = this.validate().form();\r\n            } else {\r\n                errorList = [];\r\n                valid = true;\r\n                validator = $(this[0].form).validate();\r\n                this.each(function () {\r\n                    valid = validator.element(this) && valid;\r\n                    if (!valid) {\r\n                        errorList = errorList.concat(validator.errorList);\r\n                    }\r\n                });\r\n                validator.errorList = errorList;\r\n            }\r\n            return valid;\r\n        },\r\n\r\n        // http://jqueryvalidation.org/rules/\r\n        rules: function (command, argument) {\r\n            var element = this[0],\r\n                settings, staticRules, existingRules, data, param, filtered;\r\n\r\n            // If nothing is selected, return empty object; can't chain anyway\r\n            if (element == null || element.form == null) {\r\n                return;\r\n            }\r\n\r\n            if (command) {\r\n                settings = $.data(element.form, \"validator\").settings;\r\n                staticRules = settings.rules;\r\n                existingRules = $.validator.staticRules(element);\r\n                switch (command) {\r\n                    case \"add\":\r\n                        $.extend(existingRules, $.validator.normalizeRule(argument));\r\n\r\n                        // Remove messages from rules, but allow them to be set separately\r\n                        delete existingRules.messages;\r\n                        staticRules[element.name] = existingRules;\r\n                        if (argument.messages) {\r\n                            settings.messages[element.name] = $.extend(settings.messages[element.name], argument.messages);\r\n                        }\r\n                        break;\r\n                    case \"remove\":\r\n                        if (!argument) {\r\n                            delete staticRules[element.name];\r\n                            return existingRules;\r\n                        }\r\n                        filtered = {};\r\n                        $.each(argument.split(/\\s/), function (index, method) {\r\n                            filtered[method] = existingRules[method];\r\n                            delete existingRules[method];\r\n                            if (method === \"required\") {\r\n                                $(element).removeAttr(\"aria-required\");\r\n                            }\r\n                        });\r\n                        return filtered;\r\n                }\r\n            }\r\n\r\n            data = $.validator.normalizeRules(\r\n                $.extend(\r\n                    {},\r\n                    $.validator.classRules(element),\r\n                    $.validator.attributeRules(element),\r\n                    $.validator.dataRules(element),\r\n                    $.validator.staticRules(element)\r\n                ), element);\r\n\r\n            // Make sure required is at front\r\n            if (data.required) {\r\n                param = data.required;\r\n                delete data.required;\r\n                data = $.extend({required: param}, data);\r\n                $(element).attr(\"aria-required\", \"true\");\r\n            }\r\n\r\n            // Make sure remote is at back\r\n            if (data.remote) {\r\n                param = data.remote;\r\n                delete data.remote;\r\n                data = $.extend(data, {remote: param});\r\n            }\r\n\r\n            return data;\r\n        }\r\n    });\r\n\r\n// Custom selectors\r\n    $.extend($.expr.pseudos || $.expr[\":\"], {\t\t// '|| $.expr[ \":\" ]' here enables backwards compatibility to jQuery 1.7. Can be removed when dropping jQ 1.7.x support\r\n\r\n        // http://jqueryvalidation.org/blank-selector/\r\n        blank: function (a) {\r\n            return !$.trim(\"\" + $(a).val());\r\n        },\r\n\r\n        // http://jqueryvalidation.org/filled-selector/\r\n        filled: function (a) {\r\n            var val = $(a).val();\r\n            return val !== null && !!$.trim(\"\" + val);\r\n        },\r\n\r\n        // http://jqueryvalidation.org/unchecked-selector/\r\n        unchecked: function (a) {\r\n            return !$(a).prop(\"checked\");\r\n        }\r\n    });\r\n\r\n// Constructor for validator\r\n    $.validator = function (options, form) {\r\n        this.settings = $.extend(true, {}, $.validator.defaults, options);\r\n        this.currentForm = form;\r\n        this.init();\r\n    };\r\n\r\n// http://jqueryvalidation.org/jQuery.validator.format/\r\n    $.validator.format = function (source, params) {\r\n        if (arguments.length === 1) {\r\n            return function () {\r\n                var args = $.makeArray(arguments);\r\n                args.unshift(source);\r\n                return $.validator.format.apply(this, args);\r\n            };\r\n        }\r\n        if (params === undefined) {\r\n            return source;\r\n        }\r\n        if (arguments.length > 2 && params.constructor !== Array) {\r\n            params = $.makeArray(arguments).slice(1);\r\n        }\r\n        if (params.constructor !== Array) {\r\n            params = [params];\r\n        }\r\n        $.each(params, function (i, n) {\r\n            source = source.replace(new RegExp(\"\\\\{\" + i + \"\\\\}\", \"g\"), function () {\r\n                return n;\r\n            });\r\n        });\r\n        return source;\r\n    };\r\n\r\n    $.extend($.validator, {\r\n\r\n        defaults: {\r\n            messages: {},\r\n            groups: {},\r\n            rules: {},\r\n            errorClass: \"error\",\r\n            pendingClass: \"pending\",\r\n            validClass: \"valid\",\r\n            errorElement: \"label\",\r\n            focusCleanup: false,\r\n            focusInvalid: true,\r\n            errorContainer: $([]),\r\n            errorLabelContainer: $([]),\r\n            onsubmit: true,\r\n            ignore: \":hidden\",\r\n            ignoreTitle: false,\r\n            onfocusin: function (element) {\r\n                this.lastActive = element;\r\n\r\n                // Hide error label and remove error class on focus if enabled\r\n                if (this.settings.focusCleanup) {\r\n                    if (this.settings.unhighlight) {\r\n                        this.settings.unhighlight.call(this, element, this.settings.errorClass, this.settings.validClass);\r\n                    }\r\n                    this.hideThese(this.errorsFor(element));\r\n                }\r\n            },\r\n            onfocusout: function (element) {\r\n                if (!this.checkable(element) && ( element.name in this.submitted || !this.optional(element) )) {\r\n                    this.element(element);\r\n                }\r\n            },\r\n            onkeyup: function (element, event) {\r\n\r\n                // Avoid revalidate the field when pressing one of the following keys\r\n                // Shift       => 16\r\n                // Ctrl        => 17\r\n                // Alt         => 18\r\n                // Caps lock   => 20\r\n                // End         => 35\r\n                // Home        => 36\r\n                // Left arrow  => 37\r\n                // Up arrow    => 38\r\n                // Right arrow => 39\r\n                // Down arrow  => 40\r\n                // Insert      => 45\r\n                // Num lock    => 144\r\n                // AltGr key   => 225\r\n                var excludedKeys = [\r\n                    16, 17, 18, 20, 35, 36, 37,\r\n                    38, 39, 40, 45, 144, 225\r\n                ];\r\n\r\n                if (event.which === 9 && this.elementValue(element) === \"\" || $.inArray(event.keyCode, excludedKeys) !== -1) {\r\n                    return;\r\n                } else if (element.name in this.submitted || element.name in this.invalid) {\r\n                    this.element(element);\r\n                }\r\n            },\r\n            onclick: function (element) {\r\n\r\n                // Click on selects, radiobuttons and checkboxes\r\n                if (element.name in this.submitted) {\r\n                    this.element(element);\r\n\r\n                    // Or option elements, check parent select in that case\r\n                } else if (element.parentNode.name in this.submitted) {\r\n                    this.element(element.parentNode);\r\n                }\r\n            },\r\n            highlight: function (element, errorClass, validClass) {\r\n                if (element.type === \"radio\") {\r\n                    this.findByName(element.name).addClass(errorClass).removeClass(validClass);\r\n                } else {\r\n                    $(element).addClass(errorClass).removeClass(validClass);\r\n                }\r\n            },\r\n            unhighlight: function (element, errorClass, validClass) {\r\n                if (element.type === \"radio\") {\r\n                    this.findByName(element.name).removeClass(errorClass).addClass(validClass);\r\n                } else {\r\n                    $(element).removeClass(errorClass).addClass(validClass);\r\n                }\r\n            }\r\n        },\r\n\r\n        // http://jqueryvalidation.org/jQuery.validator.setDefaults/\r\n        setDefaults: function (settings) {\r\n            $.extend($.validator.defaults, settings);\r\n        },\r\n\r\n        messages: {\r\n            required: \"This field is required.\",\r\n            remote: \"Please fix this field.\",\r\n            email: \"Please enter a valid email address.\",\r\n            url: \"Please enter a valid URL.\",\r\n            date: \"Please enter a valid date.\",\r\n            dateISO: \"Please enter a valid date (ISO).\",\r\n            number: \"Please enter a valid number.\",\r\n            digits: \"Please enter only digits.\",\r\n            equalTo: \"Please enter the same value again.\",\r\n            maxlength: $.validator.format(\"Please enter no more than {0} characters.\"),\r\n            minlength: $.validator.format(\"Please enter at least {0} characters.\"),\r\n            rangelength: $.validator.format(\"Please enter a value between {0} and {1} characters long.\"),\r\n            range: $.validator.format(\"Please enter a value between {0} and {1}.\"),\r\n            max: $.validator.format(\"Please enter a value less than or equal to {0}.\"),\r\n            min: $.validator.format(\"Please enter a value greater than or equal to {0}.\"),\r\n            step: $.validator.format(\"Please enter a multiple of {0}.\")\r\n        },\r\n\r\n        autoCreateRanges: false,\r\n\r\n        prototype: {\r\n\r\n            init: function () {\r\n                this.labelContainer = $(this.settings.errorLabelContainer);\r\n                this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm);\r\n                this.containers = $(this.settings.errorContainer).add(this.settings.errorLabelContainer);\r\n                this.submitted = {};\r\n                this.valueCache = {};\r\n                this.pendingRequest = 0;\r\n                this.pending = {};\r\n                this.invalid = {};\r\n                this.reset();\r\n\r\n                var groups = ( this.groups = {} ),\r\n                    rules;\r\n                $.each(this.settings.groups, function (key, value) {\r\n                    if (typeof value === \"string\") {\r\n                        value = value.split(/\\s/);\r\n                    }\r\n                    $.each(value, function (index, name) {\r\n                        groups[name] = key;\r\n                    });\r\n                });\r\n                rules = this.settings.rules;\r\n                $.each(rules, function (key, value) {\r\n                    rules[key] = $.validator.normalizeRule(value);\r\n                });\r\n\r\n                function delegate(event) {\r\n\r\n                    // Set form expando on contenteditable\r\n                    if (!this.form && this.hasAttribute(\"contenteditable\")) {\r\n                        this.form = $(this).closest(\"form\")[0];\r\n                    }\r\n\r\n                    var validator = $.data(this.form, \"validator\"),\r\n                        eventType = \"on\" + event.type.replace(/^validate/, \"\"),\r\n                        settings = validator.settings;\r\n                    if (settings[eventType] && !$(this).is(settings.ignore)) {\r\n                        settings[eventType].call(validator, this, event);\r\n                    }\r\n                }\r\n\r\n                $(this.currentForm)\r\n                    .on(\"focusin.validate focusout.validate keyup.validate\",\r\n                        \":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], \" +\r\n                        \"[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], \" +\r\n                        \"[type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], \" +\r\n                        \"[type='radio'], [type='checkbox'], [contenteditable], [type='button']\", delegate)\r\n\r\n                    // Support: Chrome, oldIE\r\n                    // \"select\" is provided as event.target when clicking a option\r\n                    .on(\"click.validate\", \"select, option, [type='radio'], [type='checkbox']\", delegate);\r\n\r\n                if (this.settings.invalidHandler) {\r\n                    $(this.currentForm).on(\"invalid-form.validate\", this.settings.invalidHandler);\r\n                }\r\n\r\n                // Add aria-required to any Static/Data/Class required fields before first validation\r\n                // Screen readers require this attribute to be present before the initial submission http://www.w3.org/TR/WCAG-TECHS/ARIA2.html\r\n                $(this.currentForm).find(\"[required], [data-rule-required], .required\").attr(\"aria-required\", \"true\");\r\n            },\r\n\r\n            // http://jqueryvalidation.org/Validator.form/\r\n            form: function () {\r\n                this.checkForm();\r\n                $.extend(this.submitted, this.errorMap);\r\n                this.invalid = $.extend({}, this.errorMap);\r\n                if (!this.valid()) {\r\n                    $(this.currentForm).triggerHandler(\"invalid-form\", [this]);\r\n                }\r\n                this.showErrors();\r\n                return this.valid();\r\n            },\r\n\r\n            checkForm: function () {\r\n                this.prepareForm();\r\n                for (var i = 0, elements = ( this.currentElements = this.elements() ); elements[i]; i++) {\r\n                    this.check(elements[i]);\r\n                }\r\n                return this.valid();\r\n            },\r\n\r\n            // http://jqueryvalidation.org/Validator.element/\r\n            element: function (element) {\r\n                var cleanElement = this.clean(element),\r\n                    checkElement = this.validationTargetFor(cleanElement),\r\n                    v = this,\r\n                    result = true,\r\n                    rs, group;\r\n\r\n                if (checkElement === undefined) {\r\n                    delete this.invalid[cleanElement.name];\r\n                } else {\r\n                    this.prepareElement(checkElement);\r\n                    this.currentElements = $(checkElement);\r\n\r\n                    // If this element is grouped, then validate all group elements already\r\n                    // containing a value\r\n                    group = this.groups[checkElement.name];\r\n                    if (group) {\r\n                        $.each(this.groups, function (name, testgroup) {\r\n                            if (testgroup === group && name !== checkElement.name) {\r\n                                cleanElement = v.validationTargetFor(v.clean(v.findByName(name)));\r\n                                if (cleanElement && cleanElement.name in v.invalid) {\r\n                                    v.currentElements.push(cleanElement);\r\n                                    result = v.check(cleanElement) && result;\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    rs = this.check(checkElement) !== false;\r\n                    result = result && rs;\r\n                    if (rs) {\r\n                        this.invalid[checkElement.name] = false;\r\n                    } else {\r\n                        this.invalid[checkElement.name] = true;\r\n                    }\r\n\r\n                    if (!this.numberOfInvalids()) {\r\n\r\n                        // Hide error containers on last error\r\n                        this.toHide = this.toHide.add(this.containers);\r\n                    }\r\n                    this.showErrors();\r\n\r\n                    // Add aria-invalid status for screen readers\r\n                    $(element).attr(\"aria-invalid\", !rs);\r\n                }\r\n\r\n                return result;\r\n            },\r\n\r\n            // http://jqueryvalidation.org/Validator.showErrors/\r\n            showErrors: function (errors) {\r\n                if (errors) {\r\n                    var validator = this;\r\n\r\n                    // Add items to error list and map\r\n                    $.extend(this.errorMap, errors);\r\n                    this.errorList = $.map(this.errorMap, function (message, name) {\r\n                        return {\r\n                            message: message,\r\n                            element: validator.findByName(name)[0]\r\n                        };\r\n                    });\r\n\r\n                    // Remove items from success list\r\n                    this.successList = $.grep(this.successList, function (element) {\r\n                        return !( element.name in errors );\r\n                    });\r\n                }\r\n                if (this.settings.showErrors) {\r\n                    this.settings.showErrors.call(this, this.errorMap, this.errorList);\r\n                } else {\r\n                    this.defaultShowErrors();\r\n                }\r\n            },\r\n\r\n            // http://jqueryvalidation.org/Validator.resetForm/\r\n            resetForm: function () {\r\n                if ($.fn.resetForm) {\r\n                    $(this.currentForm).resetForm();\r\n                }\r\n                this.invalid = {};\r\n                this.submitted = {};\r\n                this.prepareForm();\r\n                this.hideErrors();\r\n                var elements = this.elements()\r\n                    .removeData(\"previousValue\")\r\n                    .removeAttr(\"aria-invalid\");\r\n\r\n                this.resetElements(elements);\r\n            },\r\n\r\n            resetElements: function (elements) {\r\n                var i;\r\n\r\n                if (this.settings.unhighlight) {\r\n                    for (i = 0; elements[i]; i++) {\r\n                        this.settings.unhighlight.call(this, elements[i],\r\n                            this.settings.errorClass, \"\");\r\n                        this.findByName(elements[i].name).removeClass(this.settings.validClass);\r\n                    }\r\n                } else {\r\n                    elements\r\n                        .removeClass(this.settings.errorClass)\r\n                        .removeClass(this.settings.validClass);\r\n                }\r\n            },\r\n\r\n            numberOfInvalids: function () {\r\n                return this.objectLength(this.invalid);\r\n            },\r\n\r\n            objectLength: function (obj) {\r\n                /* jshint unused: false */\r\n                var count = 0,\r\n                    i;\r\n                for (i in obj) {\r\n                    if (obj[i]) {\r\n                        count++;\r\n                    }\r\n                }\r\n                return count;\r\n            },\r\n\r\n            hideErrors: function () {\r\n                this.hideThese(this.toHide);\r\n            },\r\n\r\n            hideThese: function (errors) {\r\n                errors.not(this.containers).text(\"\");\r\n                this.addWrapper(errors).hide();\r\n            },\r\n\r\n            valid: function () {\r\n                return this.size() === 0;\r\n            },\r\n\r\n            size: function () {\r\n                return this.errorList.length;\r\n            },\r\n\r\n            focusInvalid: function () {\r\n                if (this.settings.focusInvalid) {\r\n                    try {\r\n                        $(this.findLastActive() || this.errorList.length && this.errorList[0].element || [])\r\n                            .filter(\":visible\")\r\n                            .focus()\r\n\r\n                            // Manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find\r\n                            .trigger(\"focusin\");\r\n                    } catch (e) {\r\n\r\n                        // Ignore IE throwing errors when focusing hidden elements\r\n                    }\r\n                }\r\n            },\r\n\r\n            findLastActive: function () {\r\n                var lastActive = this.lastActive;\r\n                return lastActive && $.grep(this.errorList, function (n) {\r\n                        return n.element.name === lastActive.name;\r\n                    }).length === 1 && lastActive;\r\n            },\r\n\r\n            elements: function () {\r\n                var validator = this,\r\n                    rulesCache = {};\r\n\r\n                // Select all valid inputs inside the form (no submit or reset buttons)\r\n                return $(this.currentForm)\r\n                    .find(\"input, select, textarea, [contenteditable]\")\r\n                    .not(\":submit, :reset, :image, :disabled\")\r\n                    .not(this.settings.ignore)\r\n                    .filter(function () {\r\n                        var name = this.name || $(this).attr(\"name\"); // For contenteditable\r\n                        if (!name && validator.settings.debug && window.console) {\r\n                            console.error(\"%o has no name assigned\", this);\r\n                        }\r\n\r\n                        // Set form expando on contenteditable\r\n                        if (this.hasAttribute(\"contenteditable\")) {\r\n                            this.form = $(this).closest(\"form\")[0];\r\n                        }\r\n\r\n                        // Select only the first element for each name, and only those with rules specified\r\n                        if (name in rulesCache || !validator.objectLength($(this).rules())) {\r\n                            return false;\r\n                        }\r\n\r\n                        rulesCache[name] = true;\r\n                        return true;\r\n                    });\r\n            },\r\n\r\n            clean: function (selector) {\r\n                return $(selector)[0];\r\n            },\r\n\r\n            errors: function () {\r\n                var errorClass = this.settings.errorClass.split(\" \").join(\".\");\r\n                return $(this.settings.errorElement + \".\" + errorClass, this.errorContext);\r\n            },\r\n\r\n            resetInternals: function () {\r\n                this.successList = [];\r\n                this.errorList = [];\r\n                this.errorMap = {};\r\n                this.toShow = $([]);\r\n                this.toHide = $([]);\r\n            },\r\n\r\n            reset: function () {\r\n                this.resetInternals();\r\n                this.currentElements = $([]);\r\n            },\r\n\r\n            prepareForm: function () {\r\n                this.reset();\r\n                this.toHide = this.errors().add(this.containers);\r\n            },\r\n\r\n            prepareElement: function (element) {\r\n                this.reset();\r\n                this.toHide = this.errorsFor(element);\r\n            },\r\n\r\n            elementValue: function (element) {\r\n                var $element = $(element),\r\n                    type = element.type,\r\n                    val, idx;\r\n\r\n                if (type === \"radio\" || type === \"checkbox\") {\r\n                    return this.findByName(element.name).filter(\":checked\").val();\r\n                } else if (type === \"number\" && typeof element.validity !== \"undefined\") {\r\n                    return element.validity.badInput ? \"NaN\" : $element.val();\r\n                }\r\n\r\n                if (element.hasAttribute(\"contenteditable\")) {\r\n                    val = $element.text();\r\n                } else {\r\n                    val = $element.val();\r\n                }\r\n\r\n                if (type === \"file\") {\r\n\r\n                    // Modern browser (chrome & safari)\r\n                    if (val.substr(0, 12) === \"C:\\\\fakepath\\\\\") {\r\n                        return val.substr(12);\r\n                    }\r\n\r\n                    // Legacy browsers\r\n                    // Unix-based path\r\n                    idx = val.lastIndexOf(\"/\");\r\n                    if (idx >= 0) {\r\n                        return val.substr(idx + 1);\r\n                    }\r\n\r\n                    // Windows-based path\r\n                    idx = val.lastIndexOf(\"\\\\\");\r\n                    if (idx >= 0) {\r\n                        return val.substr(idx + 1);\r\n                    }\r\n\r\n                    // Just the file name\r\n                    return val;\r\n                }\r\n\r\n                if (typeof val === \"string\") {\r\n                    return val.replace(/\\r/g, \"\");\r\n                }\r\n                return val;\r\n            },\r\n\r\n            check: function (element) {\r\n                element = this.validationTargetFor(this.clean(element));\r\n\r\n                var rules = $(element).rules(),\r\n                    rulesCount = $.map(rules, function (n, i) {\r\n                        return i;\r\n                    }).length,\r\n                    dependencyMismatch = false,\r\n                    val = this.elementValue(element),\r\n                    result, method, rule;\r\n\r\n                // If a normalizer is defined for this element, then\r\n                // call it to retreive the changed value instead\r\n                // of using the real one.\r\n                // Note that `this` in the normalizer is `element`.\r\n                if (typeof rules.normalizer === \"function\") {\r\n                    val = rules.normalizer.call(element, val);\r\n\r\n                    if (typeof val !== \"string\") {\r\n                        throw new TypeError(\"The normalizer should return a string value.\");\r\n                    }\r\n\r\n                    // Delete the normalizer from rules to avoid treating\r\n                    // it as a pre-defined method.\r\n                    delete rules.normalizer;\r\n                }\r\n\r\n                for (method in rules) {\r\n                    rule = {method: method, parameters: rules[method]};\r\n                    try {\r\n                        result = $.validator.methods[method].call(this, val, element, rule.parameters);\r\n\r\n                        // If a method indicates that the field is optional and therefore valid,\r\n                        // don't mark it as valid when there are no other rules\r\n                        if (result === \"dependency-mismatch\" && rulesCount === 1) {\r\n                            dependencyMismatch = true;\r\n                            continue;\r\n                        }\r\n                        dependencyMismatch = false;\r\n\r\n                        if (result === \"pending\") {\r\n                            this.toHide = this.toHide.not(this.errorsFor(element));\r\n                            return;\r\n                        }\r\n\r\n                        if (!result) {\r\n                            this.formatAndAdd(element, rule);\r\n                            return false;\r\n                        }\r\n                    } catch (e) {\r\n                        if (this.settings.debug && window.console) {\r\n                            console.log(\"Exception occurred when checking element \" + element.id + \", check the '\" + rule.method + \"' method.\", e);\r\n                        }\r\n                        if (e instanceof TypeError) {\r\n                            e.message += \".  Exception occurred when checking element \" + element.id + \", check the '\" + rule.method + \"' method.\";\r\n                        }\r\n\r\n                        throw e;\r\n                    }\r\n                }\r\n                if (dependencyMismatch) {\r\n                    return;\r\n                }\r\n                if (this.objectLength(rules)) {\r\n                    this.successList.push(element);\r\n                }\r\n                return true;\r\n            },\r\n\r\n            // Return the custom message for the given element and validation method\r\n            // specified in the element's HTML5 data attribute\r\n            // return the generic message if present and no method specific message is present\r\n            customDataMessage: function (element, method) {\r\n                return $(element).data(\"msg\" + method.charAt(0).toUpperCase() +\r\n                        method.substring(1).toLowerCase()) || $(element).data(\"msg\");\r\n            },\r\n\r\n            // Return the custom message for the given element name and validation method\r\n            customMessage: function (name, method) {\r\n                var m = this.settings.messages[name];\r\n                return m && ( m.constructor === String ? m : m[method] );\r\n            },\r\n\r\n            // Return the first defined argument, allowing empty strings\r\n            findDefined: function () {\r\n                for (var i = 0; i < arguments.length; i++) {\r\n                    if (arguments[i] !== undefined) {\r\n                        return arguments[i];\r\n                    }\r\n                }\r\n                return undefined;\r\n            },\r\n\r\n            // The second parameter 'rule' used to be a string, and extended to an object literal\r\n            // of the following form:\r\n            // rule = {\r\n            //     method: \"method name\",\r\n            //     parameters: \"the given method parameters\"\r\n            // }\r\n            //\r\n            // The old behavior still supported, kept to maintain backward compatibility with\r\n            // old code, and will be removed in the next major release.\r\n            defaultMessage: function (element, rule) {\r\n                if (typeof rule === \"string\") {\r\n                    rule = {method: rule};\r\n                }\r\n\r\n                var message = this.findDefined(\r\n                    this.customMessage(element.name, rule.method),\r\n                    this.customDataMessage(element, rule.method),\r\n\r\n                    // 'title' is never undefined, so handle empty string as undefined\r\n                        !this.settings.ignoreTitle && element.title || undefined,\r\n                    $.validator.messages[rule.method],\r\n                        \"<strong>Warning: No message defined for \" + element.name + \"</strong>\"\r\n                    ),\r\n                    theregex = /\\$?\\{(\\d+)\\}/g;\r\n                if (typeof message === \"function\") {\r\n                    message = message.call(this, rule.parameters, element);\r\n                } else if (theregex.test(message)) {\r\n                    message = $.validator.format(message.replace(theregex, \"{$1}\"), rule.parameters);\r\n                }\r\n\r\n                return message;\r\n            },\r\n\r\n            formatAndAdd: function (element, rule) {\r\n                var message = this.defaultMessage(element, rule);\r\n\r\n                this.errorList.push({\r\n                    message: message,\r\n                    element: element,\r\n                    method: rule.method\r\n                });\r\n\r\n                this.errorMap[element.name] = message;\r\n                this.submitted[element.name] = message;\r\n            },\r\n\r\n            addWrapper: function (toToggle) {\r\n                if (this.settings.wrapper) {\r\n                    toToggle = toToggle.add(toToggle.parent(this.settings.wrapper));\r\n                }\r\n                return toToggle;\r\n            },\r\n\r\n            defaultShowErrors: function () {\r\n                var i, elements, error;\r\n                for (i = 0; this.errorList[i]; i++) {\r\n                    error = this.errorList[i];\r\n                    if (this.settings.highlight) {\r\n                        this.settings.highlight.call(this, error.element, this.settings.errorClass, this.settings.validClass);\r\n                    }\r\n                    this.showLabel(error.element, error.message);\r\n                }\r\n                if (this.errorList.length) {\r\n                    this.toShow = this.toShow.add(this.containers);\r\n                }\r\n                if (this.settings.success) {\r\n                    for (i = 0; this.successList[i]; i++) {\r\n                        this.showLabel(this.successList[i]);\r\n                    }\r\n                }\r\n                if (this.settings.unhighlight) {\r\n                    for (i = 0, elements = this.validElements(); elements[i]; i++) {\r\n                        this.settings.unhighlight.call(this, elements[i], this.settings.errorClass, this.settings.validClass);\r\n                    }\r\n                }\r\n                this.toHide = this.toHide.not(this.toShow);\r\n                this.hideErrors();\r\n                this.addWrapper(this.toShow).show();\r\n            },\r\n\r\n            validElements: function () {\r\n                return this.currentElements.not(this.invalidElements());\r\n            },\r\n\r\n            invalidElements: function () {\r\n                return $(this.errorList).map(function () {\r\n                    return this.element;\r\n                });\r\n            },\r\n\r\n            showLabel: function (element, message) {\r\n                var place, group, errorID, v,\r\n                    error = this.errorsFor(element),\r\n                    elementID = this.idOrName(element),\r\n                    describedBy = $(element).attr(\"aria-describedby\");\r\n\r\n                if (error.length) {\r\n\r\n                    // Refresh error/success class\r\n                    error.removeClass(this.settings.validClass).addClass(this.settings.errorClass);\r\n\r\n                    // Replace message on existing label\r\n                    error.html(message);\r\n                } else {\r\n\r\n                    // Create error element\r\n                    error = $(\"<\" + this.settings.errorElement + \">\")\r\n                        .attr(\"id\", elementID + \"-error\")\r\n                        .addClass(this.settings.errorClass)\r\n                        .html(message || \"\");\r\n\r\n                    // Maintain reference to the element to be placed into the DOM\r\n                    place = error;\r\n                    if (this.settings.wrapper) {\r\n\r\n                        // Make sure the element is visible, even in IE\r\n                        // actually showing the wrapped element is handled elsewhere\r\n                        place = error.hide().show().wrap(\"<\" + this.settings.wrapper + \"/>\").parent();\r\n                    }\r\n                    if (this.labelContainer.length) {\r\n                        this.labelContainer.append(place);\r\n                    } else if (this.settings.errorPlacement) {\r\n                        this.settings.errorPlacement.call(this, place, $(element));\r\n                    } else {\r\n                        place.insertAfter(element);\r\n                    }\r\n\r\n                    // Link error back to the element\r\n                    if (error.is(\"label\")) {\r\n\r\n                        // If the error is a label, then associate using 'for'\r\n                        error.attr(\"for\", elementID);\r\n\r\n                        // If the element is not a child of an associated label, then it's necessary\r\n                        // to explicitly apply aria-describedby\r\n                    } else if (error.parents(\"label[for='\" + this.escapeCssMeta(elementID) + \"']\").length === 0) {\r\n                        errorID = error.attr(\"id\");\r\n\r\n                        // Respect existing non-error aria-describedby\r\n                        if (!describedBy) {\r\n                            describedBy = errorID;\r\n                        } else if (!describedBy.match(new RegExp(\"\\\\b\" + this.escapeCssMeta(errorID) + \"\\\\b\"))) {\r\n\r\n                            // Add to end of list if not already present\r\n                            describedBy += \" \" + errorID;\r\n                        }\r\n                        $(element).attr(\"aria-describedby\", describedBy);\r\n\r\n                        // If this element is grouped, then assign to all elements in the same group\r\n                        group = this.groups[element.name];\r\n                        if (group) {\r\n                            v = this;\r\n                            $.each(v.groups, function (name, testgroup) {\r\n                                if (testgroup === group) {\r\n                                    $(\"[name='\" + v.escapeCssMeta(name) + \"']\", v.currentForm)\r\n                                        .attr(\"aria-describedby\", error.attr(\"id\"));\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                if (!message && this.settings.success) {\r\n                    error.text(\"\");\r\n                    if (typeof this.settings.success === \"string\") {\r\n                        error.addClass(this.settings.success);\r\n                    } else {\r\n                        this.settings.success(error, element);\r\n                    }\r\n                }\r\n                this.toShow = this.toShow.add(error);\r\n            },\r\n\r\n            errorsFor: function (element) {\r\n                var name = this.escapeCssMeta(this.idOrName(element)),\r\n                    describer = $(element).attr(\"aria-describedby\"),\r\n                    selector = \"label[for='\" + name + \"'], label[for='\" + name + \"'] *\";\r\n\r\n                // 'aria-describedby' should directly reference the error element\r\n                if (describer) {\r\n                    selector = selector + \", #\" + this.escapeCssMeta(describer)\r\n                            .replace(/\\s+/g, \", #\");\r\n                }\r\n\r\n                return this\r\n                    .errors()\r\n                    .filter(selector);\r\n            },\r\n\r\n            // See https://api.jquery.com/category/selectors/, for CSS\r\n            // meta-characters that should be escaped in order to be used with JQuery\r\n            // as a literal part of a name/id or any selector.\r\n            escapeCssMeta: function (string) {\r\n                return string.replace(/([\\\\!\"#$%&'()*+,./:;<=>?@\\[\\]^`{|}~])/g, \"\\\\$1\");\r\n            },\r\n\r\n            idOrName: function (element) {\r\n                return this.groups[element.name] || ( this.checkable(element) ? element.name : element.id || element.name );\r\n            },\r\n\r\n            validationTargetFor: function (element) {\r\n\r\n                // If radio/checkbox, validate first element in group instead\r\n                if (this.checkable(element)) {\r\n                    element = this.findByName(element.name);\r\n                }\r\n\r\n                // Always apply ignore filter\r\n                return $(element).not(this.settings.ignore)[0];\r\n            },\r\n\r\n            checkable: function (element) {\r\n                return ( /radio|checkbox/i ).test(element.type);\r\n            },\r\n\r\n            findByName: function (name) {\r\n                return $(this.currentForm).find(\"[name='\" + this.escapeCssMeta(name) + \"']\");\r\n            },\r\n\r\n            getLength: function (value, element) {\r\n                switch (element.nodeName.toLowerCase()) {\r\n                    case \"select\":\r\n                        return $(\"option:selected\", element).length;\r\n                    case \"input\":\r\n                        if (this.checkable(element)) {\r\n                            return this.findByName(element.name).filter(\":checked\").length;\r\n                        }\r\n                }\r\n                return value.length;\r\n            },\r\n\r\n            depend: function (param, element) {\r\n                return this.dependTypes[typeof param] ? this.dependTypes[typeof param](param, element) : true;\r\n            },\r\n\r\n            dependTypes: {\r\n                \"boolean\": function (param) {\r\n                    return param;\r\n                },\r\n                \"string\": function (param, element) {\r\n                    return !!$(param, element.form).length;\r\n                },\r\n                \"function\": function (param, element) {\r\n                    return param(element);\r\n                }\r\n            },\r\n\r\n            optional: function (element) {\r\n                var val = this.elementValue(element);\r\n                return !$.validator.methods.required.call(this, val, element) && \"dependency-mismatch\";\r\n            },\r\n\r\n            startRequest: function (element) {\r\n                if (!this.pending[element.name]) {\r\n                    this.pendingRequest++;\r\n                    $(element).addClass(this.settings.pendingClass);\r\n                    this.pending[element.name] = true;\r\n                }\r\n            },\r\n\r\n            stopRequest: function (element, valid) {\r\n                this.pendingRequest--;\r\n\r\n                // Sometimes synchronization fails, make sure pendingRequest is never < 0\r\n                if (this.pendingRequest < 0) {\r\n                    this.pendingRequest = 0;\r\n                }\r\n                delete this.pending[element.name];\r\n                $(element).removeClass(this.settings.pendingClass);\r\n                if (valid && this.pendingRequest === 0 && this.formSubmitted && this.form()) {\r\n                    $(this.currentForm).submit();\r\n                    this.formSubmitted = false;\r\n                } else if (!valid && this.pendingRequest === 0 && this.formSubmitted) {\r\n                    $(this.currentForm).triggerHandler(\"invalid-form\", [this]);\r\n                    this.formSubmitted = false;\r\n                }\r\n            },\r\n\r\n            previousValue: function (element, method) {\r\n                method = typeof method === \"string\" && method || \"remote\";\r\n\r\n                return $.data(element, \"previousValue\") || $.data(element, \"previousValue\", {\r\n                        old: null,\r\n                        valid: true,\r\n                        message: this.defaultMessage(element, {method: method})\r\n                    });\r\n            },\r\n\r\n            // Cleans up all forms and elements, removes validator-specific events\r\n            destroy: function () {\r\n                this.resetForm();\r\n\r\n                $(this.currentForm)\r\n                    .off(\".validate\")\r\n                    .removeData(\"validator\")\r\n                    .find(\".validate-equalTo-blur\")\r\n                    .off(\".validate-equalTo\")\r\n                    .removeClass(\"validate-equalTo-blur\");\r\n            }\r\n\r\n        },\r\n\r\n        classRuleSettings: {\r\n            required: {required: true},\r\n            email: {email: true},\r\n            url: {url: true},\r\n            date: {date: true},\r\n            dateISO: {dateISO: true},\r\n            number: {number: true},\r\n            digits: {digits: true},\r\n            creditcard: {creditcard: true}\r\n        },\r\n\r\n        addClassRules: function (className, rules) {\r\n            if (className.constructor === String) {\r\n                this.classRuleSettings[className] = rules;\r\n            } else {\r\n                $.extend(this.classRuleSettings, className);\r\n            }\r\n        },\r\n\r\n        classRules: function (element) {\r\n            var rules = {},\r\n                classes = $(element).attr(\"class\");\r\n\r\n            if (classes) {\r\n                $.each(classes.split(\" \"), function () {\r\n                    if (this in $.validator.classRuleSettings) {\r\n                        $.extend(rules, $.validator.classRuleSettings[this]);\r\n                    }\r\n                });\r\n            }\r\n            return rules;\r\n        },\r\n\r\n        normalizeAttributeRule: function (rules, type, method, value) {\r\n\r\n            // Convert the value to a number for number inputs, and for text for backwards compability\r\n            // allows type=\"date\" and others to be compared as strings\r\n            if (/min|max|step/.test(method) && ( type === null || /number|range|text/.test(type) )) {\r\n                value = Number(value);\r\n\r\n                // Support Opera Mini, which returns NaN for undefined minlength\r\n                if (isNaN(value)) {\r\n                    value = undefined;\r\n                }\r\n            }\r\n\r\n            if (value || value === 0) {\r\n                rules[method] = value;\r\n            } else if (type === method && type !== \"range\") {\r\n\r\n                // Exception: the jquery validate 'range' method\r\n                // does not test for the html5 'range' type\r\n                rules[method] = true;\r\n            }\r\n        },\r\n\r\n        attributeRules: function (element) {\r\n            var rules = {},\r\n                $element = $(element),\r\n                type = element.getAttribute(\"type\"),\r\n                method, value;\r\n\r\n            for (method in $.validator.methods) {\r\n\r\n                // Support for <input required> in both html5 and older browsers\r\n                if (method === \"required\") {\r\n                    value = element.getAttribute(method);\r\n\r\n                    // Some browsers return an empty string for the required attribute\r\n                    // and non-HTML5 browsers might have required=\"\" markup\r\n                    if (value === \"\") {\r\n                        value = true;\r\n                    }\r\n\r\n                    // Force non-HTML5 browsers to return bool\r\n                    value = !!value;\r\n                } else {\r\n                    value = $element.attr(method);\r\n                }\r\n\r\n                this.normalizeAttributeRule(rules, type, method, value);\r\n            }\r\n\r\n            // 'maxlength' may be returned as -1, 2147483647 ( IE ) and 524288 ( safari ) for text inputs\r\n            if (rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength)) {\r\n                delete rules.maxlength;\r\n            }\r\n\r\n            return rules;\r\n        },\r\n\r\n        dataRules: function (element) {\r\n            var rules = {},\r\n                $element = $(element),\r\n                type = element.getAttribute(\"type\"),\r\n                method, value;\r\n\r\n            for (method in $.validator.methods) {\r\n                value = $element.data(\"rule\" + method.charAt(0).toUpperCase() + method.substring(1).toLowerCase());\r\n                this.normalizeAttributeRule(rules, type, method, value);\r\n            }\r\n            return rules;\r\n        },\r\n\r\n        staticRules: function (element) {\r\n            var rules = {},\r\n                validator = $.data(element.form, \"validator\");\r\n\r\n            if (validator.settings.rules) {\r\n                rules = $.validator.normalizeRule(validator.settings.rules[element.name]) || {};\r\n            }\r\n            return rules;\r\n        },\r\n\r\n        normalizeRules: function (rules, element) {\r\n\r\n            // Handle dependency check\r\n            $.each(rules, function (prop, val) {\r\n\r\n                // Ignore rule when param is explicitly false, eg. required:false\r\n                if (val === false) {\r\n                    delete rules[prop];\r\n                    return;\r\n                }\r\n                if (val.param || val.depends) {\r\n                    var keepRule = true;\r\n                    switch (typeof val.depends) {\r\n                        case \"string\":\r\n                            keepRule = !!$(val.depends, element.form).length;\r\n                            break;\r\n                        case \"function\":\r\n                            keepRule = val.depends.call(element, element);\r\n                            break;\r\n                    }\r\n                    if (keepRule) {\r\n                        rules[prop] = val.param !== undefined ? val.param : true;\r\n                    } else {\r\n                        $.data(element.form, \"validator\").resetElements($(element));\r\n                        delete rules[prop];\r\n                    }\r\n                }\r\n            });\r\n\r\n            // Evaluate parameters\r\n            $.each(rules, function (rule, parameter) {\r\n                rules[rule] = $.isFunction(parameter) && rule !== \"normalizer\" ? parameter(element) : parameter;\r\n            });\r\n\r\n            // Clean number parameters\r\n            $.each([\"minlength\", \"maxlength\"], function () {\r\n                if (rules[this]) {\r\n                    rules[this] = Number(rules[this]);\r\n                }\r\n            });\r\n            $.each([\"rangelength\", \"range\"], function () {\r\n                var parts;\r\n                if (rules[this]) {\r\n                    if ($.isArray(rules[this])) {\r\n                        rules[this] = [Number(rules[this][0]), Number(rules[this][1])];\r\n                    } else if (typeof rules[this] === \"string\") {\r\n                        parts = rules[this].replace(/[\\[\\]]/g, \"\").split(/[\\s,]+/);\r\n                        rules[this] = [Number(parts[0]), Number(parts[1])];\r\n                    }\r\n                }\r\n            });\r\n\r\n            if ($.validator.autoCreateRanges) {\r\n\r\n                // Auto-create ranges\r\n                if (rules.min != null && rules.max != null) {\r\n                    rules.range = [rules.min, rules.max];\r\n                    delete rules.min;\r\n                    delete rules.max;\r\n                }\r\n                if (rules.minlength != null && rules.maxlength != null) {\r\n                    rules.rangelength = [rules.minlength, rules.maxlength];\r\n                    delete rules.minlength;\r\n                    delete rules.maxlength;\r\n                }\r\n            }\r\n\r\n            return rules;\r\n        },\r\n\r\n        // Converts a simple string to a {string: true} rule, e.g., \"required\" to {required:true}\r\n        normalizeRule: function (data) {\r\n            if (typeof data === \"string\") {\r\n                var transformed = {};\r\n                $.each(data.split(/\\s/), function () {\r\n                    transformed[this] = true;\r\n                });\r\n                data = transformed;\r\n            }\r\n            return data;\r\n        },\r\n\r\n        // http://jqueryvalidation.org/jQuery.validator.addMethod/\r\n        addMethod: function (name, method, message) {\r\n            $.validator.methods[name] = method;\r\n            $.validator.messages[name] = message !== undefined ? message : $.validator.messages[name];\r\n            if (method.length < 3) {\r\n                $.validator.addClassRules(name, $.validator.normalizeRule(name));\r\n            }\r\n        },\r\n\r\n        // http://jqueryvalidation.org/jQuery.validator.methods/\r\n        methods: {\r\n\r\n            // http://jqueryvalidation.org/required-method/\r\n            required: function (value, element, param) {\r\n\r\n                // Check if dependency is met\r\n                if (!this.depend(param, element)) {\r\n                    return \"dependency-mismatch\";\r\n                }\r\n                if (element.nodeName.toLowerCase() === \"select\") {\r\n\r\n                    // Could be an array for select-multiple or a string, both are fine this way\r\n                    var val = $(element).val();\r\n                    return val && val.length > 0;\r\n                }\r\n                if (this.checkable(element)) {\r\n                    return this.getLength(value, element) > 0;\r\n                }\r\n                return value.length > 0;\r\n            },\r\n\r\n            // http://jqueryvalidation.org/email-method/\r\n            email: function (value, element) {\r\n\r\n                // From https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address\r\n                // Retrieved 2014-01-14\r\n                // If you have a problem with this implementation, report a bug against the above spec\r\n                // Or use custom methods to implement your own email validation\r\n                return this.optional(element) || /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(value);\r\n            },\r\n\r\n            // http://jqueryvalidation.org/url-method/\r\n            url: function (value, element) {\r\n\r\n                // Copyright (c) 2010-2013 Diego Perini, MIT licensed\r\n                // https://gist.github.com/dperini/729294\r\n                // see also https://mathiasbynens.be/demo/url-regex\r\n                // modified to allow protocol-relative URLs\r\n                return this.optional(element) || /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})).?)(?::\\d{2,5})?(?:[/?#]\\S*)?$/i.test(value);\r\n            },\r\n\r\n            // http://jqueryvalidation.org/date-method/\r\n            date: function (value, element) {\r\n                return this.optional(element) || !/Invalid|NaN/.test(new Date(value).toString());\r\n            },\r\n\r\n            // http://jqueryvalidation.org/dateISO-method/\r\n            dateISO: function (value, element) {\r\n                return this.optional(element) || /^\\d{4}[\\/\\-](0?[1-9]|1[012])[\\/\\-](0?[1-9]|[12][0-9]|3[01])$/.test(value);\r\n            },\r\n\r\n            // http://jqueryvalidation.org/number-method/\r\n            number: function (value, element) {\r\n                return this.optional(element) || /^(?:-?\\d+|-?\\d{1,3}(?:,\\d{3})+)?(?:\\.\\d+)?$/.test(value);\r\n            },\r\n\r\n            // http://jqueryvalidation.org/digits-method/\r\n            digits: function (value, element) {\r\n                return this.optional(element) || /^\\d+$/.test(value);\r\n            },\r\n\r\n            // http://jqueryvalidation.org/minlength-method/\r\n            minlength: function (value, element, param) {\r\n                var length = $.isArray(value) ? value.length : this.getLength(value, element);\r\n                return this.optional(element) || length >= param;\r\n            },\r\n\r\n            // http://jqueryvalidation.org/maxlength-method/\r\n            maxlength: function (value, element, param) {\r\n                var length = $.isArray(value) ? value.length : this.getLength(value, element);\r\n                return this.optional(element) || length <= param;\r\n            },\r\n\r\n            // http://jqueryvalidation.org/rangelength-method/\r\n            rangelength: function (value, element, param) {\r\n                var length = $.isArray(value) ? value.length : this.getLength(value, element);\r\n                return this.optional(element) || ( length >= param[0] && length <= param[1] );\r\n            },\r\n\r\n            // http://jqueryvalidation.org/min-method/\r\n            min: function (value, element, param) {\r\n                return this.optional(element) || value >= param;\r\n            },\r\n\r\n            // http://jqueryvalidation.org/max-method/\r\n            max: function (value, element, param) {\r\n                return this.optional(element) || value <= param;\r\n            },\r\n\r\n            // http://jqueryvalidation.org/range-method/\r\n            range: function (value, element, param) {\r\n                return this.optional(element) || ( value >= param[0] && value <= param[1] );\r\n            },\r\n\r\n            // http://jqueryvalidation.org/step-method/\r\n            step: function (value, element, param) {\r\n                var type = $(element).attr(\"type\"),\r\n                    errorMessage = \"Step attribute on input type \" + type + \" is not supported.\",\r\n                    supportedTypes = [\"text\", \"number\", \"range\"],\r\n                    re = new RegExp(\"\\\\b\" + type + \"\\\\b\"),\r\n                    notSupported = type && !re.test(supportedTypes.join()),\r\n                    decimalPlaces = function (num) {\r\n                        var match = ( \"\" + num ).match(/(?:\\.(\\d+))?$/);\r\n                        if (!match) {\r\n                            return 0;\r\n                        }\r\n\r\n                        // Number of digits right of decimal point.\r\n                        return match[1] ? match[1].length : 0;\r\n                    },\r\n                    toInt = function (num) {\r\n                        return Math.round(num * Math.pow(10, decimals));\r\n                    },\r\n                    valid = true,\r\n                    decimals;\r\n\r\n                // Works only for text, number and range input types\r\n                // TODO find a way to support input types date, datetime, datetime-local, month, time and week\r\n                if (notSupported) {\r\n                    throw new Error(errorMessage);\r\n                }\r\n\r\n                decimals = decimalPlaces(param);\r\n\r\n                // Value can't have too many decimals\r\n                if (decimalPlaces(value) > decimals || toInt(value) % toInt(param) !== 0) {\r\n                    valid = false;\r\n                }\r\n\r\n                return this.optional(element) || valid;\r\n            },\r\n\r\n            // http://jqueryvalidation.org/equalTo-method/\r\n            equalTo: function (value, element, param) {\r\n\r\n                // Bind to the blur event of the target in order to revalidate whenever the target field is updated\r\n                var target = $(param);\r\n                if (this.settings.onfocusout && target.not(\".validate-equalTo-blur\").length) {\r\n                    target.addClass(\"validate-equalTo-blur\").on(\"blur.validate-equalTo\", function () {\r\n                        $(element).valid();\r\n                    });\r\n                }\r\n                return value === target.val();\r\n            },\r\n\r\n            // http://jqueryvalidation.org/remote-method/\r\n            remote: function (value, element, param, method) {\r\n                if (this.optional(element)) {\r\n                    return \"dependency-mismatch\";\r\n                }\r\n\r\n                method = typeof method === \"string\" && method || \"remote\";\r\n\r\n                var previous = this.previousValue(element, method),\r\n                    validator, data, optionDataString;\r\n\r\n                if (!this.settings.messages[element.name]) {\r\n                    this.settings.messages[element.name] = {};\r\n                }\r\n                previous.originalMessage = previous.originalMessage || this.settings.messages[element.name][method];\r\n                this.settings.messages[element.name][method] = previous.message;\r\n\r\n                param = typeof param === \"string\" && {url: param} || param;\r\n                optionDataString = $.param($.extend({data: value}, param.data));\r\n                if (previous.old === optionDataString) {\r\n                    return previous.valid;\r\n                }\r\n\r\n                previous.old = optionDataString;\r\n                validator = this;\r\n                this.startRequest(element);\r\n                data = {};\r\n                data[element.name] = value;\r\n                $.ajax($.extend(true, {\r\n                    mode: \"abort\",\r\n                    port: \"validate\" + element.name,\r\n                    dataType: \"json\",\r\n                    data: data,\r\n                    context: validator.currentForm,\r\n                    success: function (response) {\r\n                        var valid = response === true || response === \"true\",\r\n                            errors, message, submitted;\r\n\r\n                        validator.settings.messages[element.name][method] = previous.originalMessage;\r\n                        if (valid) {\r\n                            submitted = validator.formSubmitted;\r\n                            validator.resetInternals();\r\n                            validator.toHide = validator.errorsFor(element);\r\n                            validator.formSubmitted = submitted;\r\n                            validator.successList.push(element);\r\n                            validator.invalid[element.name] = false;\r\n                            validator.showErrors();\r\n                        } else {\r\n                            errors = {};\r\n                            message = response || validator.defaultMessage(element, {\r\n                                    method: method,\r\n                                    parameters: value\r\n                                });\r\n                            errors[element.name] = previous.message = message;\r\n                            validator.invalid[element.name] = true;\r\n                            validator.showErrors(errors);\r\n                        }\r\n                        previous.valid = valid;\r\n                        validator.stopRequest(element, valid);\r\n                    }\r\n                }, param));\r\n                return \"pending\";\r\n            }\r\n        }\r\n\r\n    });\r\n\r\n// Ajax mode: abort\r\n// usage: $.ajax({ mode: \"abort\"[, port: \"uniqueport\"]});\r\n// if mode:\"abort\" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()\r\n\r\n    var pendingRequests = {},\r\n        ajax;\r\n\r\n// Use a prefilter if available (1.5+)\r\n    if ($.ajaxPrefilter) {\r\n        $.ajaxPrefilter(function (settings, _, xhr) {\r\n            var port = settings.port;\r\n            if (settings.mode === \"abort\") {\r\n                if (pendingRequests[port]) {\r\n                    pendingRequests[port].abort();\r\n                }\r\n                pendingRequests[port] = xhr;\r\n            }\r\n        });\r\n    } else {\r\n\r\n        // Proxy ajax\r\n        ajax = $.ajax;\r\n        $.ajax = function (settings) {\r\n            var mode = ( \"mode\" in settings ? settings : $.ajaxSettings ).mode,\r\n                port = ( \"port\" in settings ? settings : $.ajaxSettings ).port;\r\n            if (mode === \"abort\") {\r\n                if (pendingRequests[port]) {\r\n                    pendingRequests[port].abort();\r\n                }\r\n                pendingRequests[port] = ajax.apply(this, arguments);\r\n                return pendingRequests[port];\r\n            }\r\n            return ajax.apply(this, arguments);\r\n        };\r\n    }\r\n    return $;\r\n}));"],"file":"jquery.validate.js"}